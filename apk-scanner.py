import os.path
import argparse
import subprocess
import time
import tqdm
import json
import requests
from requests_toolbelt.multipart.encoder import MultipartEncoder
from colorama import Fore, Back
from texttable import Texttable
import threading
from queue import Queue
import re

banner = r"""
    ___          __   _____
   /   |  ____  / /__/ ___/_________ _____  ____  ___  _____
  / /| | / __ \/ //_/\__ \/ ___/ __ `/ __ \/ __ \/ _ \/ ___/
 / ___ |/ /_/ / ,<  ___/ / /__/ /_/ / / / / / / /  __/ /
/_/  |_/ .___/_/|_|/____/\___/\__,_/_/ /_/_/ /_/\___/_/
      /_/
                                                    phongdk

"""
parser = argparse.ArgumentParser(prog='APK Scanner', 
                                usage='python apk-scanner.py apk-file or run.bat apk-file', 
                                epilog='Example: python apk-scanner.py apk-file or run.bat apk-file', 
                                description='A pen-testing tool to automatically finding information of apk file')

parser.add_argument('apkfile', metavar='apk-file', help='name of the apk file')

activities = []
services = []
receivers = []
providers = []
permissions = []
dangerous_perm = []
isBackup = False
isDebug = False
package_name = ""
jadx = r"jadx\bin\jadx"

SERVER = "http://localhost:8000"
APIKEY = '286a755dfce115f42eb02b6ce7709bd1fb787164e3c85b41dacb3df6e654d023'
apkfile = ''

#Upload file APK 
def upload(apkfile):
    multipart_data = MultipartEncoder(fields={'file': (apkfile, open(apkfile, 'rb'), 'application/octet-stream')})
    headers = {'Content-Type': multipart_data.content_type, 'Authorization': APIKEY}
    pbar = tqdm.tqdm(range (100), desc=" [-] Uploading apk file:", ncols=80)
    response = requests.post(SERVER + '/api/v1/upload', data=multipart_data, headers=headers)
    for i in pbar:
        time.sleep(0.01)
        if (i == 99):
            pbar.set_description(" [+] Upload completed")
    return response.text

#Scanning APK
def scanInfor(data):
    isDebug = False
    print("Scanning file:")
    post_dict = json.loads(data)
    headers = {'Authorization': APIKEY}
    pbar = tqdm.tqdm(range (100), desc=" [-] Scanning apk file:", ncols=80)
    response = requests.post(SERVER + '/api/v1/scan', data=post_dict, headers=headers)
    for i in pbar:
        time.sleep(0.01)
        if (i == 99):
            pbar.set_description(" [+] Scan completed")
    res = json.loads(response.text)
    t = Texttable(max_width=200)
    t.add_row(['No','Issue','Severity','Standards','Files'])
    code_analysis = res['code_analysis']['findings']
    global package_name 
    package_name = res['package_name']

    print(Fore. GREEN + "\nPackage name: " + package_name )
    print("Version: " +res['version_name'])
    print("Min SDK: " + res['min_sdk'], "Target SDK: " + res['target_sdk'] + Fore.WHITE)
    #Phân tích code
    c=1
    for i in code_analysis:
        files = []
        des = code_analysis[i]['metadata']['description']
        sev = code_analysis[i]['metadata']['severity']
        standards = []
        if code_analysis[i]['metadata']['cwe'] != '':
            standards.append('CWE: '+code_analysis[i]['metadata']['cwe'])
        if code_analysis[i]['metadata']['owasp-mobile'] != '':
            standards.append('OWASP Top 10 Mobile 2016: '+code_analysis[i]['metadata']['owasp-mobile'])
        if code_analysis[i]['metadata']['masvs'] != '':
            standards.append('OWASP MASVS: ' + code_analysis[i]['metadata']['masvs'])
        for x in code_analysis[i]['files']:
           files.append(x)
        t.add_row([c, des, sev,'\n'.join(standards),'\n'.join(files)])
        c+=1
    if c == 1:
        t.add_row(['No issues found','','','',''])

    #App permissions
    for x, y in res['permissions'].items():
        permissions.append(x)
        if y['status'] == 'dangerous':
            dangerous_perm.append(x)
    for i in res['manifest_analysis']['manifest_findings']:
        if i['rule'] == 'app_is_debuggable':
            isDebug = True
        if i['rule'] == 'app_allowbackup':
            isBackup = True
        if i['rule'] == 'explicitly_exported' or i['rule'] == 'exported_intent_filter_exists':
            if i['component'][0] == 'Activity':
                activities.append(i['component'][1])
            elif i['component'][0] == 'Broadcast Receiver':
                receivers.append(i['component'][1])
            elif i['component'][0] == 'Content Provider':
                providers.append(i['component'][1])
            elif i['component'][0] == 'Service':
                services.append(i['component'][1])

    print("\n==================================================================")
    if res["appsec"]["security_score"] < 15:
        print(Fore.PURPLE + "\033[1m" + "SECURITY SCORE: " + str(res["appsec"]["security_score"]) +"/100" +" - RISK: CRITICAL" + "\033[0m" + Fore.PURPLE)
    elif res["appsec"]["security_score"] < 40:
        print(Fore.RED + "\033[1m" + "SECURITY SCORE: " + str(res["appsec"]["security_score"]) +"/100" +" - RISK: HIGH"  + "\033[0m" + Fore.WHITE)
    elif res["appsec"]["security_score"] < 60:
        print(Fore.YELLOW + "\033[1m" + "SECURITY SCORE: " + str(res["appsec"]["security_score"]) +"/100" +" - RISK: MEDIUM" + "\033[0m" + Fore.WHITE)
    else:
        print(Fore.GREEN + "\033[1m" + "SECURITY SCORE: " + str(res["appsec"]["security_score"]) +"/100" +" - RISK: LOW" +"\033[0m" + Fore.WHITE)
    print("==================================================================")

    print(Fore.CYAN + "\033[1m" + "Application Permissions:" + "\033[0m" + Fore.WHITE)
    perms = Texttable()
    perms.add_row(['Permissions',"Severity"])
    for i in permissions:
        if i in dangerous_perm:
            perms.add_row([i,"dangerous"])
        else:
            perms.add_row([i,"normal"])
    print(perms.draw())

    print(Fore.CYAN + "\033[1m" + "Code Analysis: " + "\033[0m" + Fore.WHITE)
    print(t.draw())

    print("\n==================================================================")
    if res['virus_total']['positives'] >0 :
        print(Fore.RED + "\033[1m" + "Virustotal Detection: " + str(res['virus_total']['positives'])+ "/" +str(res['virus_total']['total']) + "\033[0m" + Fore.WHITE)
    else:
        print(Fore.GREEN + "\033[1m" + "Virustotal Detection: " + str(res['virus_total']['positives'])+"/" +str(res['virus_total']['total']) + "\033[0m" + Fore.WHITE)
    print(Fore.CYAN +"Reference: " + res["virus_total"]['permalink'] + Fore.WHITE)
    print("==================================================================")

    virustotal = {}
    for x,y in res['virus_total']['scans'].items():
        if y['detected']:
            virustotal.update({x:y['result']})
    
    vst = Texttable()
    vst.add_row(['Security vendor\'s','Detection'])
    if len(virustotal) == 0:
        vst.add_row(['No threads found',''])
    else:
        for i in virustotal.keys():
            vst.add_row([i,virustotal[i]])
    print(vst.draw())


    
    print(Fore.WHITE + '\nAttack surface:')
    print('  ',len(activities),'activity exported')
    print('  ',len(services),'service exported')
    print('  ',len(receivers),'broadcast receiver exported')
    print('  ',len(providers),'content provider exported')
    if isBackup: 
        print(Fore.YELLOW + '    is allow backup' + Fore.WHITE)
    if isDebug: 
        print( Fore.YELLOW +'    is debuggable' + Fore.WHITE) 

#Check file existed
def isExist(filename):
    return os.path.exists(filename)

def decompile_apk(apkfile):
    try:
        subprocess.Popen([jadx, apkfile],  stdout=subprocess.PIPE,shell=True)
    except subprocess.CalledProcessError as e:
        print(f"Error in decompiling APK: {e}")

def get_urls_in_file(file_path, url_pattern, urls):
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                matches = url_pattern.findall(line)
                with threading.Lock():
                    urls.update(matches)
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")

def finder(url_pattern, urls, queue):
    while True:
            file_path = queue.get()
            if file_path is None:
                break
            get_urls_in_file(file_path, url_pattern, urls)
            queue.task_done()

# find uri for content provider
def findall_urls(folder_path, num_threads=4):
    url_pattern = re.compile(r'content://[^"\']+')
    urls = set()
    file_queue = Queue()

    threads = []
    for _ in range(num_threads):
        thread = threading.Thread(target=finder, args=(url_pattern, urls, file_queue))
        thread.start()
        threads.append(thread)

    for root, _, files in os.walk(folder_path):
        for file in files:
            file_queue.put(os.path.join(root, file))

    file_queue.join() 
    for _ in range(num_threads):
        file_queue.put(None)
    for thread in threads:
        thread.join()
    return urls

def activityAttack(apkfile):
    while True:
        print("Select acitivity by id:")
        for i,v in enumerate(activities):
            print(f"  {i}. {v}")
        user_input = (input('> '))
        if user_input == 'back' or user_input == 'b':
            attack(apkfile)
            break
        elif user_input == 'exit':
            break
        try:
            if int(user_input) > len(activities)-1:
                print('Error, Please select again\n')
            else:

                act_name = activities[int(user_input)]
                global package_name
                act = act_name[:len(package_name)] + "/" +  act_name[len(package_name):]
                arr_argv = ['adb', 'shell','am', 'start','-S' , act]
                a = input("Does this activity have any extra data? (Y/n) ")
                extra = []
                if a =='y' or a == 'Y' or a=='':
                    while True:
                        e = input("Enter extra data for this activity:\nEg: extra_key extra_value extra_key1 extra_value1: ").split()
                        if len(e)%2==1:
                            print(Fore.RED +"\nExtra data must be a pair key and value:" + Fore.WHITE)
                        else: 
                            for i in range (0,len(e),2):
                                arr_argv.append('-e')
                                arr_argv.append(e[i])
                                arr_argv.append(e[i+1])
                            break
                cmd = subprocess.Popen(arr_argv, stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
                a = cmd.communicate()
                if 'no devices' in str(a[1]):
                    print('Error, Please ensure your virtual machine is opened!!!')
                elif 'does not exist' in str(a[1]):
                    print('Error, Please install application first!!!')
                else: print('Activity is started, please check your device!!!\n')
        except ValueError : 
            print('Error, Please select again\n')
    
def serviceAttack(apkfile):
    while True:
        print("Select service by id:")
        for i,v in enumerate(services):
            print(f"  {i}. {v}")
        user_input = (input('> '))
        if user_input == 'back' or user_input == 'b':
            attack(apkfile)
            break
        elif user_input == 'exit':
            break
        try:
            if int(user_input) > len(services)-1:
                print('Error, Please select again\n')
            else:
                serv_name = services[int(user_input)]
                global package_name
                serv = serv_name[:len(package_name)] + "/" +  serv_name[len(package_name):]
                arr_argv = ['adb', 'shell','am', 'startservice', serv]
                cmd = subprocess.Popen(arr_argv, stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
                print('Service is started, please check your device')
        except ValueError : 
            print('Error, Please select again\n')

def receiverAttack(apkfile):
    while True:
        print("Select receiver by id:")
        for i,v in enumerate(receivers):
            print(f"  {i}. {v}")
        user_input = (input('> '))
        if user_input == 'back' or user_input == 'b':
            attack(apkfile)
            break
        elif user_input == 'exit':
            break
        try:
            if int(user_input) > len(receivers)-1:
                print('Error, Please select again\n')
            else:
                recei_name = receivers[int(user_input)]
                global package_name
                recei = recei_name[:len(package_name)] + "/" +  recei_name[len(package_name):]

                arr_argv = ['adb', 'shell','am', 'broadcast', recei]
                cmd = subprocess.Popen(arr_argv, stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
                print('Broadcast is started, please check your device')
        except ValueError : 
            print('Error, Please select again\n')


def providerAttack(apkfile):
    while True:
        print("Select content provider by id:")
        for i,v in enumerate(providers):
            print(f"  {i}. {v}")
        user_input = (input('> '))
        if user_input == 'back' or user_input == 'b':
            attack(apkfile)
            break
        elif user_input == 'exit':
            break
        try:
            if int(user_input) > len(providers)-1:
                print('Error, Please select again\n')
            else:
                provider_name = providers[int(user_input)]
                urls = findall_urls(apkfile[:-4]+r'\sources')
                uris = []
                for uri in urls:
                    if provider_name in uri:
                        uris.append(uri)    
                while True:
                    print("\nSelect content provider URI:")
                    for uri in uris:
                        print(f"  {i}. {uri}")
                    a = input("> ")
                    if int(a) > len(providers)-1:
                        print('Error, Please select again\n')
                    else:
                        arr_argv = ['adb', 'shell','content', 'query','--uri', uri]
                        cmd = subprocess.run(arr_argv,shell=True)
                        break
                        
                
        except ValueError : 
            print('Error, Please select again\n')
    

def attack(apkfile):
    while True:
        print('\nWhat\'s components you wanna attack?\n  0. activity\n  1. service\n  2. receiver\n  3. content providers')
        user_input = input('> ')
        if user_input.lower() == 'exit':
            break
        else:
            if user_input == '0':
                if(len(activities)>0):
                    activityAttack(apkfile)
                else:
                    print('This componnent cannot attack because cannot find attack surface')
                break
            elif user_input == '1':
                if(len(services)>0):
                    serviceAttack(apkfile)
                else:
                    print('This componnent cannot attack because cannot find attack surface')
                break 
            elif user_input == '2':
                if(len(receivers)>0):
                    receiverAttack(apkfile)
                else:
                    print('This componnent cannot attack because cannot find attack surface')
                break 
            elif user_input == '3':
                if(len(providers)>0):
                    providerAttack(apkfile)
                else:
                    print('This componnent cannot attack because cannot find attack surface')
                break 
            else:
                print('Error, Please select again\n')

    
def main():
    print( Fore.YELLOW + banner + Fore.WHITE)
    args = parser.parse_args()
    apkfile = args.apkfile
    if '.apk' not in apkfile:
        print("Invalid APK File")
    else:
        print("APK file: " + apkfile)
        if not isExist(apkfile[:-4]):
            decompile_apk(apkfile)
        data = upload(apkfile)
        print("\nScanning Information:")
    
        scanInfor(data)

        a = input("Do you want to attack components exported? (Y/n) ")
        if (a == 'Y' or a == 'y' or a == ''):
            attack(apkfile)
if __name__ == "__main__":
    main()
