import os.path
import argparse
import subprocess
import time
import tqdm
import json
import requests
from requests_toolbelt.multipart.encoder import MultipartEncoder
from colorama import Fore, Back
from texttable import Texttable
import threading
from queue import Queue
import re

banner = r"""
    ___          __   _____
   /   |  ____  / /__/ ___/_________ _____  ____  ___  _____
  / /| | / __ \/ //_/\__ \/ ___/ __ `/ __ \/ __ \/ _ \/ ___/
 / ___ |/ /_/ / ,<  ___/ / /__/ /_/ / / / / / / /  __/ /
/_/  |_/ .___/_/|_|/____/\___/\__,_/_/ /_/_/ /_/\___/_/
      /_/
                                                    phongdk

"""
parser = argparse.ArgumentParser(prog='APK Scanner', 
                                usage='python apk-scanner.py apk-file or run.bat apk-file', 
                                epilog='Example: python apk-scanner.py apk-file or run.bat apk-file', 
                                description='A pen-testing tool to automatically finding information of apk file')

parser.add_argument('apkfile', metavar='apk-file', help='name of the apk file')

activities = []
services = []
receivers = []
providers = []
permissions = []
dangerous_perm = []
isBackup = False
isDebug = False
jadx = r"jadx\bin\jadx"

SERVER = "https://c08b-113-20-108-53.ngrok-free.app"
APIKEY = '188eabbe9c17fbf382d7b677d56f2711920535538b61d92c7630e69c7bb85b58'
apkfile = ''

#Upload file APK 
def upload(apkfile):
    multipart_data = MultipartEncoder(fields={'file': (apkfile, open(apkfile, 'rb'), 'application/octet-stream')})
    headers = {'Content-Type': multipart_data.content_type, 'Authorization': APIKEY}
    pbar = tqdm.tqdm(range (100), desc=" [-] Uploading apk file:", ncols=80)
    response = requests.post(SERVER + '/api/v1/upload', data=multipart_data, headers=headers)
    for i in pbar:
        time.sleep(0.01)
        if (i == 99):
            pbar.set_description(" [+] Upload completed")
    return response.text

#Scanning APK
def scanInfor(data):
    print("Scanning file:")
    post_dict = json.loads(data)
    headers = {'Authorization': APIKEY}
    pbar = tqdm.tqdm(range (100), desc=" [-] Scanning apk file:", ncols=80)
    response = requests.post(SERVER + '/api/v1/scan', data=post_dict, headers=headers)
    for i in pbar:
        time.sleep(0.01)
        if (i == 99):
            pbar.set_description(" [+] Scan completed")
    res = json.loads(response.text)
    t = Texttable(max_width=200)
    t.add_row(['No','Issue','Severity','Standards','Files'])
    code_analysis = res['code_analysis']['findings']
    c=1
    for i in code_analysis:
        files = []
        des = code_analysis[i]['metadata']['description']
        sev = code_analysis[i]['metadata']['severity']
        standards = []
        if code_analysis[i]['metadata']['cwe'] != '':
            standards.append('CWE: '+code_analysis[i]['metadata']['cwe'])
        if code_analysis[i]['metadata']['owasp-mobile'] != '':
            standards.append('OWASP Top 10 Mobile 2016: '+code_analysis[i]['metadata']['owasp-mobile'])
        if code_analysis[i]['metadata']['masvs'] != '':
            standards.append('OWASP MASVS: ' + code_analysis[i]['metadata']['masvs'])
        for x in code_analysis[i]['files']:
           files.append(x)
        t.add_row([c, des, sev,'\n'.join(standards),'\n'.join(files)])
        c+=1
    print(t.draw())
    
    for x, y in res['permissions'].items():
        permissions.append(x)
        if y['status'] == 'dangerous':
            dangerous_perm.append(x)
    for i in res['manifest_analysis']['manifest_findings']:
        if i['rule'] == 'app_is_debuggable':
            isDebug = True
        if i['rule'] == 'app_allowbackup':
            isBackup = True
        if i['rule'] == 'explicitly_exported' or i['rule'] == 'exported_intent_filter_exists':
            if i['component'][0] == 'Activity':
                activities.append(i['component'][1])
            elif i['component'][0] == 'Broadcast Receiver':
                receivers.append(i['component'][1])
            elif i['component'][0] == 'Content Provider':
                providers.append(i['component'][1])
            elif i['component'][0] == 'Service':
                services.append(i['component'][1])
    
    print('\nApplications Permissions:')
    for i in permissions:
        if i in dangerous_perm:
            continue
        else: print('  ' + Fore.CYAN + i)
    
    for i in dangerous_perm:
        print('  ' + Fore.RED + i)

    print(Fore.WHITE + '\nAttack surface:')
    print('  ',len(activities),'activities exported')
    print('  ',len(services),'services exported')
    print('  ',len(receivers),'broadcast receivers exported')
    print('  ',len(providers),'content provider exported')
    if isBackup: print(Fore.YELLOW + '    is allow backup')
    if isDebug: print('    is debuggable' + Fore.WHITE)

#Check file existed
def isExist(filename):
    return os.path.exists(filename)

def decompile_apk(apkfile):
    try:
        subprocess.Popen([jadx, apkfile],  stdout=subprocess.PIPE,shell=True)
    except subprocess.CalledProcessError as e:
        print(f"Error in decompiling APK: {e}")

def get_urls_in_file(file_path, url_pattern, urls):
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                matches = url_pattern.findall(line)
                with threading.Lock():
                    urls.update(matches)
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")

def finder(url_pattern, urls, queue):
    while True:
            file_path = queue.get()
            if file_path is None:
                break
            get_urls_in_file(file_path, url_pattern, urls)
            queue.task_done()

def findall_urls(folder_path, num_threads=4):
    url_pattern = re.compile(r'content://[^"\']+')
    urls = set()
    file_queue = Queue()

    threads = []
    for _ in range(num_threads):
        thread = threading.Thread(target=finder, args=(url_pattern, urls, file_queue))
        thread.start()
        threads.append(thread)

    for root, _, files in os.walk(folder_path):
        for file in files:
            file_queue.put(os.path.join(root, file))

    file_queue.join() 
    for _ in range(num_threads):
        file_queue.put(None)
    for thread in threads:
        thread.join()
    return urls

def activityAttack(apkfile):
    while True:
        print("Select acitivity by id:")
        for i,v in enumerate(activities):
            print(f"  {i}. {v}")
        user_input = (input('> '))
        if user_input == 'back' or user_input == 'b':
            attack(apkfile)
            break
        elif user_input == 'exit':
            break
        try:
            if int(user_input) > len(activities)-1:
                print('Error, Please select again\n')
            else:

                act_name = activities[int(user_input)]
                parts = act_name.rsplit('.',1)
                act_name = f"{parts[0]}/.{parts[1]}"
                arr_argv = ['adb', 'shell','am', 'start','-S' , act_name]
                a = input("Does this activity have any extra data? (Y/n) ")
                extra = []
                if a =='y' or a == 'Y' or a=='':
                    while True:
                        e = input("Enter extra data for this activity:\nEg: extra_key extra_value extra_key1 extra_value1: ").split()
                        if len(e)%2==1:
                            print(Fore.RED +"\nExtra data must be a pair key and value:" + Fore.WHITE)
                        else: 
                            for i in range (0,len(e),2):
                                arr_argv.append('-e')
                                arr_argv.append(e[i])
                                arr_argv.append(e[i+1])
                            break
                cmd = subprocess.Popen(arr_argv, stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
                a = cmd.communicate()
                if 'no devices' in str(a[1]):
                    print('Error, Please ensure your virtual machine is opened!!!')
                elif 'does not exist' in str(a[1]):
                    print('Error, Please install application first!!!')
                else: print('Activity is started, please check your device!!!\n')
        except ValueError : 
            print('Error, Please select again\n')
    
def serviceAttack(apkfile):
    while True:
        print("Select service by id:")
        for i,v in enumerate(services):
            print(f"  {i}. {v}")
        user_input = (input('> '))
        if user_input == 'back' or user_input == 'b':
            attack(apkfile)
            break
        elif user_input == 'exit':
            break
        try:
            if int(user_input) > len(services)-1:
                print('Error, Please select again\n')
            else:
                serv_name = services[int(user_input)]
                parts = serv_name.rsplit('.',1)
                serv_name = f"{parts[0]}/.{parts[1]}"
                arr_argv = ['adb', 'shell','am', 'startservice', serv_name]
                cmd = subprocess.Popen(arr_argv, stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
                print('Service is started, please check your device')
        except ValueError : 
            print('Error, Please select again\n')

def receiverAttack(apkfile):
    while True:
        print("Select receiver by id:")
        for i,v in enumerate(receivers):
            print(f"  {i}. {v}")
        user_input = (input('> '))
        if user_input == 'back' or user_input == 'b':
            attack(apkfile)
            break
        elif user_input == 'exit':
            break
        try:
            if int(user_input) > len(receivers)-1:
                print('Error, Please select again\n')
            else:
                recei_name = receivers[int(user_input)]
                parts = recei_name.rsplit('.',1)
                recei_name = f"{parts[0]}/.{parts[1]}"

                arr_argv = ['adb', 'shell','am', 'broadcast', recei_name]
                cmd = subprocess.Popen(arr_argv, stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
                print('Broadcast is started, please check your device')
        except ValueError : 
            print('Error, Please select again\n')


def providerAttack(apkfile):
    while True:
        print("Select content provider by id:")
        for i,v in enumerate(providers):
            print(f"  {i}. {v}")
        user_input = (input('> '))
        if user_input == 'back' or user_input == 'b':
            attack(apkfile)
            break
        elif user_input == 'exit':
            break
        try:
            if int(user_input) > len(providers)-1:
                print('Error, Please select again\n')
            else:
                provider_name = providers[int(user_input)]
                urls = findall_urls(apkfile[:-4]+r'\sources')
                uris = []
                for uri in urls:
                    if provider_name in uri:
                        uris.append(uri)    
                while True:
                    print("\nSelect content provider URI:")
                    for uri in uris:
                        print(f"  {i}. {uri}")
                    a = input("> ")
                    if int(a) > len(providers)-1:
                        print('Error, Please select again\n')
                    else:
                        arr_argv = ['adb', 'shell','content', 'query','--uri', uri]
                        cmd = subprocess.run(arr_argv,shell=True)
                        break
                        
                
        except ValueError : 
            print('Error, Please select again\n')
    

def attack(apkfile):
    while True:
        print('\nWhat\'s components you wanna attack?\n  0. activity\n  1. service\n  2. receiver\n  3. content providers')
        user_input = input('> ')
        if user_input.lower() == 'exit':
            break
        else:
            if user_input == '0':
                if(len(activities)>0):
                    activityAttack()
                else:
                    print('This componnent cannot attack because cannot find attack surface')
                break
            elif user_input == '1':
                if(len(services)>0):
                    serviceAttack()
                else:
                    print('This componnent cannot attack because cannot find attack surface')
                break 
            elif user_input == '2':
                if(len(receivers)>0):
                    receiverAttack()
                else:
                    print('This componnent cannot attack because cannot find attack surface')
                break 
            elif user_input == '3':
                if(len(providers)>0):
                    providerAttack(apkfile)
                else:
                    print('This componnent cannot attack because cannot find attack surface')
                break 
            else:
                print('Error, Please select again\n')

    
def main():
    print( Fore.YELLOW + banner + Fore.WHITE)
    args = parser.parse_args()
    apkfile = args.apkfile
    if '.apk' not in apkfile:
        print("Invalid APK File")
    else:
        print("APK file: " + apkfile)
        if not isExist(apkfile[:-4]):
            decompile_apk(apkfile)
        data = upload(apkfile)
        print("\nScanning Information:")
    
        scanInfor(data)

        a = input("Do you want to attack components exported? (Y/n) ")
        if (a == 'Y' or a == 'y' or a == ''):
            attack(apkfile)
if __name__ == "__main__":
    main()
